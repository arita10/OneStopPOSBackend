const express = require('express');
const router = express.Router();
const pool = require('../config/database');
const asyncHandler = require('../utils/asyncHandler');

/**
 * GET /api/transactions
 * Get all transactions with pagination
 */
router.get('/', asyncHandler(async (req, res) => {
  const { limit = 100, offset = 0 } = req.query;

  const result = await pool.query(
    `SELECT * FROM transactions
     ORDER BY created_at DESC
     LIMIT $1 OFFSET $2`,
    [parseInt(limit), parseInt(offset)]
  );

  const countResult = await pool.query('SELECT COUNT(*) FROM transactions');

  res.json({
    data: result.rows,
    total: parseInt(countResult.rows[0].count),
    limit: parseInt(limit),
    offset: parseInt(offset)
  });
}));

/**
 * GET /api/transactions/stats/summary
 * Get transaction statistics summary
 * NOTE: This must come BEFORE /:id route to avoid matching "stats" as an id
 */
router.get('/stats/summary', asyncHandler(async (req, res) => {
  const { startDate, endDate } = req.query;

  let query = `
    SELECT
      COUNT(*) as total_transactions,
      COALESCE(SUM(total), 0) as total_sales,
      COALESCE(AVG(total), 0) as average_sale,
      COALESCE(SUM(CASE WHEN payment_method = 'cash' THEN total ELSE 0 END), 0) as cash_sales,
      COALESCE(SUM(CASE WHEN payment_method = 'card' THEN total ELSE 0 END), 0) as card_sales,
      COALESCE(SUM(CASE WHEN payment_method = 'credit' THEN total ELSE 0 END), 0) as credit_sales,
      COUNT(CASE WHEN status = 'voided' THEN 1 END) as voided_transactions
    FROM transactions
    WHERE status != 'voided'
  `;
  const params = [];

  if (startDate) {
    params.push(startDate);
    query += ` AND created_at >= $${params.length}`;
  }

  if (endDate) {
    params.push(endDate);
    query += ` AND created_at <= $${params.length}`;
  }

  const result = await pool.query(query, params);

  res.json(result.rows[0]);
}));

/**
 * GET /api/transactions/:id
 * Get transaction by ID with its items
 */
router.get('/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Get transaction
  const transactionResult = await pool.query(
    'SELECT * FROM transactions WHERE id = $1',
    [id]
  );

  if (transactionResult.rows.length === 0) {
    return res.status(404).json({ error: 'Transaction not found' });
  }

  // Get transaction items
  const itemsResult = await pool.query(
    'SELECT * FROM transaction_items WHERE transaction_id = $1 ORDER BY id',
    [id]
  );

  res.json({
    ...transactionResult.rows[0],
    items: itemsResult.rows
  });
}));

/**
 * POST /api/transactions
 * Create a new transaction
 */
router.post('/', asyncHandler(async (req, res) => {
  const {
    items,
    subtotal,
    discount,
    tax,
    total,
    payment_method,
    amount_paid,
    change_amount,
    notes,
    cashier_id
  } = req.body;

  if (!items || !Array.isArray(items) || items.length === 0) {
    return res.status(400).json({ error: 'Items array is required and must not be empty' });
  }

  if (total === undefined || total === null) {
    return res.status(400).json({ error: 'Total amount is required' });
  }

  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Create the transaction (no items JSONB, no user_id)
    const transactionResult = await client.query(
      `INSERT INTO transactions
       (subtotal, discount, tax, total, payment_method, amount_paid, change_amount, notes, cashier_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
       RETURNING *`,
      [
        subtotal || 0,
        discount || 0,
        tax || 0,
        total,
        payment_method || 'cash',
        amount_paid || total,
        change_amount || 0,
        notes || null,
        cashier_id || null
      ]
    );

    const transaction = transactionResult.rows[0];
    const insertedItems = [];

    // Insert transaction items and update product stock
    for (const item of items) {
      let itemCost = 0;

      // Get product cost and update stock if product_id exists
      if (item.product_id) {
        const productResult = await client.query(
          'SELECT cost, stock FROM products WHERE id = $1',
          [item.product_id]
        );

        if (productResult.rows.length > 0) {
          itemCost = productResult.rows[0].cost || 0;

          // Update stock (decrease by quantity)
          await client.query(
            'UPDATE products SET stock = stock - $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',
            [item.quantity || 1, item.product_id]
          );
        }
      }

      // Insert into transaction_items table
      // id is UUID auto-generated by gen_random_uuid()
      const itemResult = await client.query(
        `INSERT INTO transaction_items
         (transaction_id, product_id, product_name, unit_price, cost, quantity, subtotal, is_by_weight)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
         RETURNING *`,
        [
          transaction.id,
          item.product_id || null,
          item.name || item.product_name || 'Unknown Item',
          item.price || item.unit_price || 0,
          item.cost || itemCost || 0,
          item.quantity || 1,
          item.subtotal || ((item.price || item.unit_price || 0) * (item.quantity || 1)),
          item.is_by_weight || false
        ]
      );

      insertedItems.push(itemResult.rows[0]);
    }

    await client.query('COMMIT');

    // Return transaction with items
    res.status(201).json({
      ...transaction,
      items: insertedItems
    });

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}));

/**
 * DELETE /api/transactions/:id
 * Void/delete a transaction
 */
router.delete('/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;

  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Get the transaction first
    const transactionResult = await client.query(
      'SELECT * FROM transactions WHERE id = $1',
      [id]
    );

    if (transactionResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Transaction not found' });
    }

    // Get transaction items to restore stock
    const itemsResult = await client.query(
      'SELECT * FROM transaction_items WHERE transaction_id = $1',
      [id]
    );

    // Restore product stock for each item
    for (const item of itemsResult.rows) {
      if (item.product_id) {
        await client.query(
          'UPDATE products SET stock = stock + $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',
          [item.quantity || 1, item.product_id]
        );
      }
    }

    // Mark as voided instead of deleting
    await client.query(
      "UPDATE transactions SET status = 'voided' WHERE id = $1",
      [id]
    );

    await client.query('COMMIT');
    res.json({ message: 'Transaction voided successfully' });

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}));

module.exports = router;
